

```c
#include <stdio.h>
#include <math.h>
#include <limits.h>
#include <stdbool.h>

int main()
{
    // printf("%d", (int)(~(unsigned int)0));
    // int i = INT_MAX;
    for (int i = 0; i < INT_MAX; i++)
    {
        bool b = (i == (int)(float)i);
        if (b == false)
        {
            printf("%d\n", b);
            printf("%d\n",i);
            printf("%x\n",i);
            printf("%d\n",(int)(float)i);
            break;
        }
    }
    printf("%x\n",(int)(float)(16777219));
    printf("%d\n",(int)(float)(16777219));
    float f = 16777217;
    printf("%f\n",f);
}
//输出
0
16777217
1000001
16777216
1000004
16777220
16777216.000000
```


> 对于浮点数来说，尾数M的位数反应浮点数的有效位数，他决定了数的表示精度，有效位越多，表示精度就越高；阶E的位数决定数X的表示范围；即阶E的值确定了小数点的位置。
>

对于`float`这种单精度浮点数来说，其包括1位符号位，8为阶码，23位尾数。由于隐藏位的机制，`float`最多可以容纳24尾数的能力。但IEEE754隐藏位只能是在小数点左侧，故小数表示最多为23位。

对于`int`来说，32位补码表示，范围为$\left[ -2^{31},2^{31}-1 \right]$，对于`int`转`float`来说，可能会有有效数字舍去的风险。理由如下：

一、对于`int i=1 0000 0000 0000 0000 0000 0000`来说，转化为`float`很容易。

即$1.000000000000000000000000\times 2^{23}$，小数部分为23位，可以对应`float`的23位尾数。

二、但对于`int i=1 0000 0000 0000 0000 0000 0001`来说，转化为`float`就会出现舍去

此时转化为浮点数为$1.000000000000000000000001\times 2^{24}$，拥有24位小数，转化为`float`必须舍去最后一位，造成$i\ne \left( int \right) \left( float \right) i$，以此类推，在24位小数的情况下，最后一位小数必须为0，这样才可以在舍去末尾数后不影响真值。再以此类推，在25位小数的情况下，最后两位小数必须为0，才不影响真值

**下面用代码测试**

```c
#include <stdio.h>
#include <math.h>
#include <limits.h>
#include <stdbool.h>

int main()
{
    for (int i = 16777216; i < 16777216+16; i++)
    {
        bool b = (i == (int)(float)i);
        if (b == false)
        {
            printf("%d,",i);
            printf("%d,",(int)(float)i);
            printf("%x\n",i);
        }
    }

}
//输出，舍去的数，与理论猜测一致
16777217,16777216,1000001
16777219,16777220,1000003
16777221,16777220,1000005
16777223,16777224,1000007
16777225,16777224,1000009
16777227,16777228,100000b
16777229,16777228,100000d
16777231,16777232,100000f
```

