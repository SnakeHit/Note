#### （1）传送指令

| 通用数据传送指令 |                                      |
| ---------------- | ------------------------------------ |
| MOV：            | 一般传送，包括movb、movw和movl等     |
| MOVS：           | 符号扩展传送，如movsbw、movswl等     |
| MOVZ：           | 零扩展传送，如movzwl、movzbl等       |
| XCHG：           | 数据交换                             |
| PUSH/POP：       | 入栈/出栈，如pushl,pushw,popl,popw等 |
| **地址传送指令** |                                      |
| LEA： | 加载有效地址， 如leal(%edx,%eax), %eax”的功能为 R[eax]←R[edx]+R[eax]， 执行前，若R[edx]= i ，R[eax]= j ，则指令执行后，R[eax]= i + j |
| **输入输出指令** |  |
| IN和OUT： | I/O端口与寄存器之间的交换 |
| **标志传送指令** |  |
| PUSHF、POPF： | 将EFLAG压栈，或将栈顶内容送EFLAG |

#### （2）定点算术运算指令

| 加/ 减运算        | （影响标志、不区分无/带符号）                            |
| ----------------- | -------------------------------------------------------- |
| ADD：             | 加，包括addb、addw、addl等                               |
| SUB：             | 减，包括subb、subw、subl等                               |
| **增1 / 减1运算** | **(影响除CF以外的标志、不区分无/带符号）**               |
| INC：             | 加，包括incb、incw、incl等                               |
| DEC：             | 减，包括decb、decw、decl等                               |
| **取负运算**      | **（影响标志、若对0取负，则结果为0且CF清0，否则CF置1）** |
| NEG：             | 取负，包括negb、negw、negl等                             |
| **比较运算**      | **（做减法得到标志、不区分无/带符号）**                  |
| CMP：             | 比较，包括cmpb、cmpw、cmpl等 –                           |
| **乘/ 除运算**    | **（不影响标志、区分无/带符号）**                        |
| MUL / IMUL：      | 无符号乘/ 带符号乘                                       |
| DIV/ IDIV：       | 带无符号除/ 带符号除                                     |

#### （3）按位运算指令

| 逻辑运算     |                                     |
| ------------ | ----------------------------------- |
| NOT：        | 非，包括notb、notw、notl等          |
| AND：        | 与，包括andb、andw、andl等          |
| OR：         | 或，包括orb、orw、orl等             |
| XOR：        | 异或，包括xorb、xorw、xorl等        |
| TEST：       | 做“与”操作测试，仅影响标志          |
| **移位运算** | **（左/右移时，最高/最低位送CF）**  |
| SHL/SHR:     | 逻辑左/右移，包括shlb、shrw、shrl等 |
| SAL/SAR: ||
| ROL/ROR: | 循环左/右移，包括rolb、rorw、roll等 |
| RCL/RCR: | 带进位循环左/右移，即：将CF作为操作数 一部分循环移位，  
包括rclb、rcrw、rcll等 |

#### （4）控制转移指令

| 无条件转移指令 |                               |
| -------------- | ----------------------------- |
| JMP DST：      | 无条件转移到目标指令DST处执行 |
| **条件转移**   |                               |
| Jcc DST： | cc为条件码，根据标志（条件码）判断是否满足条件，  
若满足 ，则转移到目标指令DST处执行，否则按顺序执行 |
| **条件设置** |  |
| SETcc DST： | 按条件码cc判断的结果保存到DST（是一个8位寄存器） |
| **调用和返回指令** | **（用于过程调用）** |
| CALL DST： | 返回地址RA入栈，转DST处执行 |
| RET： | 从栈中取出返回地址RA，转到RA处执行 |
| **中断指令** |  |

# 6.1 IA-32中的传送指令

### 1\. 常用传送指令

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127202013861.JPG)

### 2\. 栈

- 栈（Stack）是一种采用\*\*“先进后出”\*\* 方式进行访问的一块存储区，用于**嵌套过程调用** 。**`从高地址向低地址增长`**。
- **“入栈”（pushw%ax） 和 “出栈” （popw%ax）**  
    <img src="https://img-blog.csdnimg.cn/20181127202516581.JPG" alt="在这里插入图片描述"  />![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127202626680.JPG)

### 3\. 指令的执行

#### （1）程序由指令序列组成

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127203542595.JPG)

#### （2）指令执行过程示例

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127204053850.JPG)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/201811272041139.JPG)

#### （3）传送指令举例

将以下**Intel格式**指令转换为**AT&T格式**指令，并说明功能。

```c
//Intel格式
push ebp 
mov  ebp, esp 
mov  edx, DWORD PTR [ebp+8] 
mov  bl, 255 
mov  ax, WORD PTR [ebp+edx*4+8] 
mov  WORD PTR [ebp+20],dx 
lea  eax, [ecx+edx*4+8] 

//At&T格式
pushl %ebp //R[esp]←R[esp]-4，M[R[esp]] ←R[ebp]，双字 
movl  %esp, %ebp //R[ebp] ←R[esp]，双字 
movl  8(%ebp), %edx //R[edx] ←M[R[ebp]+8]，双字 
movb  $255, %bl //R[bl]←255，字节 
movw  8(%ebp,%edx,4), %ax   //R[ax]←M[R[ebp]+R[edx]×4+8]，字 
movw  %dx, 20(%ebp) //M[R[ebp]+20]←R[dx]，字 
leal  8(%ecx,%edx,4), %eax  //R[eax]←R[ecx]+R[edx]×4+8，双字
```

# 6.2 IA-32中的定点算数运算指令

### 1\. 运算指令

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127205124714.JPG)

### 2\. 整数乘除指令

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127205249492.JPG)

### 3\. 定点算术运算指令汇总

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127205329185.JPG)

### 4\. 指令执行过程举例

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127205523127.JPG)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127205607851.JPG)

### 5\. 定点加法指令举例

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127210208625.JPG)

### 6\. 定点乘法指令举例

#### 例一

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127210415468.JPG)

#### 布斯乘法

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127211156480.JPG)

#### 例二

> **Q:假设R\[eax\]=000000B4H，R\[ebx\]=00000011H， M\[000000F8H\]=000000A0H，请问： 执行指令“imull $-16, (%eax,%ebx,4), %eax”后哪些寄存器和存储单元发生 了变化？乘积的机器数和真值各是多少？**  
>
> **解：**  
>   “imull -16, (%eax,%ebx,4),%eax”  
>   功能为R\[eax\]←(-16)×M\[R\[eax\]+R\[ebx\]×4\] ，执行结果如下  
>   R\[eax\]+R\[ebx\]×4=000000B4H+00000011H<<2=000000F8H  
>   R\[eax\]=(-16)×M\[000000F8H\]  
>      =(-16)×000000A0H（带符号整数乘）  
>      =16 ×（-000000A0H）  
>      =FFFFFF60H<<4  
>      =FFFFF600H  
>   EAX中的真值为-2560

# 6.3 IA-32中的按位运算指令

### 1\. 按位运算指令

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127211849506.JPG)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127211734676.JPG)

### 2\. 逻辑运算指令举例

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127211950415.png)

### 3\. 按位运算指令举例

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127212040817.png)

### 4\. 移位指令举例

![在这里插入图片描述](https://img-blog.csdnimg.cn/20181127212310743.JPG)