# 寻找数组中的中心位置

给定一个整数类型的数组 `nums`，请编写一个能够返回数组 **“中心索引”** 的方法。

我们是这样定义数组 **中心索引** 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

**示例 1：**

> **输入：**
> nums = \[1, 7, 3, 6, 5, 6\]
> **输出：**3
> **解释：**
> 索引 3 (nums\[3\] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。
> 同时, 3 也是第一个符合要求的中心索引。

**示例 2：**

> **输入：**
> nums = \[1, 2, 3\]
> **输出：**\-1
> **解释：**
> 数组中不存在满足此条件的中心索引。

**说明：**

- `nums` 的长度范围为 `[0, 10000]`。
- 任何一个 `nums[i]` 将会是一个范围在 `[-1000, 1000]`的整数。

### 方法一：暴力搜索

通过对每一个数组中的元素，求在其之前的元素的和与在其之后的元素的和，并进行比较。如果相等，则返回，不相等进行下一轮迭代。

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int flag = -1;
        for(int i = 0; i < nums.length; i++){
            int leftTotal = 0;
            int rightTotal = 0;
            for(int j = 0; j < i; j++){
                leftTotal += nums[j];
            }
            for(int j = i+1; j< nums.length; j++){
                rightTotal += nums[j];
            }
            if(leftTotal == rightTotal){
                flag = i;
                break;
            }
        }
        return flag;
    }
}
```

这个方法的时间复杂度为$O(N^2)$，空间复杂度为$O(1)$。因为不对结果进行保存，每次对`i`的迭代都会对数组进行求和。

### 方法二：保留结果法

对方法一的改进，首先求出数组中所有元素的和。同时将该值赋给`rightTotal`，将`0`赋给`leftTotal`。然后每次迭代只需要让`leftTotal`迭代相加，`rightTotal`迭代相减就可以了。

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int flag = -1;
        int leftTotal = 0;
        int rightTotal = 0;
        for(int i = 0; i < nums.length; i++){
            rightTotal += nums[i];
        }
        for(int i = 0; i < nums.length; i++){
            leftTotal += nums[i];
            rightTotal -= nums[i];
            //这里应该去掉刚刚加上的值，由题意左边右边都不应该含有该值
            if(leftTotal - nums[i] == rightTotal){
                flag = i;
                break;
            }
        }
        return flag;
    }
}
```

该方法吸取了方法一的教训，将每次迭代的结果利用了起来，降低了时间复杂度。

时间复杂度为$O(N)$，空间复杂度为$O(1)$。

### 方法三：数组分半法

该方法从题意出发，如图所示，将数组分为三部分。其中`array[0]+array[1] == array[3]+array[4]+array[5]`，这时全数组的和可以演变为另一种公式
$$
Total = 2leftTotal+midle = 2rightTotal + midle
$$
![未命名绘图](C:\Users\k\Desktop\未命名绘图.svg)

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int flag = -1;
        int leftTotal = 0;
        int Total = 0;
        for(int i = 0; i < nums.length; i++){
            Total += nums[i];
        }
        for(int i = 0; i < nums.length; i++){
            leftTotal += nums[i];
            if(leftTotal * 2 + nums[i+1] == Total){
                flag = i+1;
                break;
              //由于是输出最左边的数，所以这里要中止循环
            }
        }
        return flag;
    }
}
```

