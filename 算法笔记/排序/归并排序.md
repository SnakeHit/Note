# 归并排序（分治思想）

> 归并排序是典型的以空间换时间的优化方案
>
> 他能保证将任意长度位$N$的数组排序所需时间和$NlogN$成正比；它的主要缺点是它所需要的额外空间和N成正比。

## 原地归并的抽象方法

实现归并的一种直截了当的办法是将两个不同的==有序数组==归并到第三个数组中。如果每次都产生一个新的数组的话，会造成极大的存储浪费。下面是一种只会消耗常数级内存($N$)的方法，首先将涉及到的所有元素复制到一个辅助数组中，再对归并的两个有序数组中每一个值互相比较，最后把归并的结果放回到原数组中。

```java
public static void merge(Comparable[] a, int lo, int mid, int hi)
{
    int i = lo, j = mid + 1;
    
    for(int k = lo; k <= hi; k++)
        aux[k] = a[k]; //对象变量
    for(int k = lo; k <= hi; k++)
    {
        if(i > mid)				//左半边取尽
            a[k] = aux[j++];	
        else if(j > hi)			//右半边取尽
            a[k] = aux[i++];
        else if(less(a[i], a[j]))//左半边当前元素小于右半边当前元素
            a[k] = aux[i++];
        else 					//右半边当前元素小于作左半边当前元素
            a[k] = aux[j++]
    }
}
```

## 自顶向下的归并排序（递归）

> 如果他能将两个子数组排序，他就能通过归并两个子数组来将整个数组排序

```java
public class Merge
{
    private static Comparable[] aux;
    
    public static void sort(Comparable[] a)
    {
        aux = new Comparable[a.length];
        sort(a, 0, a.length - 1);
    }
    
    private static void sort(Comparable[] a, int lo, int hi)
    {
        if(hi <= lo) return;	//递归出口
        int mid = lo + (hi - lo)/2;
        sort(a, lo, mid);
        sort(a, mid+1, hi);
        //调用完这两个排序方法后，说明a[lo..mid]和a[mid+1..hi]已经有序
        //这时可以进行判断，如果a[mid] < a[mid+1]，即不用进行merge操作
        if(a[mid] < a[mid+1])
            return;
        else
        	merge(a, lo, mid, hi);
    }
}
```

**排序过程图**

![image-20200824213827962](C:\Users\k\AppData\Roaming\Typora\typora-user-images\image-20200824213827962.png)

**改进的三种方法**

1. 对小规模子数组使用插入排序
2. 测试数组是否已经有序
3. 不将元素复制到辅助数组

==**研究一个新问题时，最好的方法是先实现一个你能想到的最简单的程序，然后对他进行改进**==

## 自底向上的归并排序

自顶向下的归并排序是分治思想的绝佳体现，将一个大问题分割成很多小问题，然后用所有小问题的答案来解决整个大问题。现在我们从反方向来思考，我们的任务就是处理许多的小问题，然后不断的合并，直到得到我们想要的结果。

```java
public class MergeBU
{
    private static Comparable[] aux;
    
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        aux = new Comparable[N];
        for(int sz = 1; sz < N; sz = sz+sz)
            for(int lo = 0; lo < N -sz; lo += sz+sz)
                merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));
    }
}
public class MergeBu
```

排序过程

![image-20200824214516675](C:\Users\k\AppData\Roaming\Typora\typora-user-images\image-20200824214516675.png)

