# 插入排序

> 插入排序类似于排序好手中的牌，从第一张开始，后面的每一张都放在相对排序好的牌中，当最后一张牌放到应该放的位置时，整个手牌也就排序好了。

与选择排序一样，当前索引左侧的所有元素都是有序的，但对于插入排序来说其最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序也就完成了。

**插入排序与初始顺序有关**。插入排序最重要的性质就是当前有序，与插入排序不同的是，==当前索引只需在左侧找到目前有序的位置就行==，而不需要与剩下的所有元素进行比较。该性质使得插入排序的时间复杂度大约是$N^2/4$，比选择排序降低了$1/2$，但由于数组在内存中是连续存储的，故索引之前与目标插入位置之后的所有元素都要往后移1位。所以需要大概$N^2/4$次交换。对于**已经排好序的数组**速度会快的多。

这是个不错的选择，abc

------

> 对于随机排列的长度为$N$且主键不重复的数组，平均情况下插入排序需要$N^2/4$次比较以及$N^2/4$交换。最坏情况下需要$N^2/2$次比较和$N^2/2$次交换，最好情况下需要$N-1$次比较和$0$次交换。

## 算法代码

```java
public class Insertion
{
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        for(int i = 1; i < N; i++)
        {
            for(int j = i; j > 0; j--)
            {
                if(less(a[j], a[j-1]))
                    exch(a, j, j-1);
                else
                    break;
            }
        }
    }
}

//首先找到要插入的位置，然后插入，不涉及到交换操作
public class Insertion
{
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        for(int i = 1; i < N; i++)
        {
            int temp = a[i];
            int j;
            for(j = i; j > 0 && less(a[j], a[j-1]); j--)
            {
                a[j] = a[j-1];
            }
            a[j] = temp;
        }
    }
}
```

