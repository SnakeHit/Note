# 快速排序

> 快速排序引人注目的特点包括它是原地排序（只需要一个很小的辅助栈），且将长度为$N$的数组排序所需要的时间和$NlogN$成正比
>
> **快速排序和归并排序一样，是一种分治的排序算法。他将一个数组分为两个子数组，将两部分独立的排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。**

**在第一种情况下，递归调用在处理整个数组之前；第二种情况下，递归调用在处理整个数组之后。**

![image-20200825110101618](C:\Users\k\AppData\Roaming\Typora\typora-user-images\image-20200825110101618.png)

## 代码

```java
public class Quick
{
    public static void sort(Comparable[] a)
    {
        StdRandom.shuffle(a);
        sort(a, 0, a.length - 1);
    }
    
    public static void sort(Comparable[] a, int lo, int hi)
    {
        if(hi <= lo + M) 
        {
            Insertion.sort(a, lo, hi); //小数组用插入排序
            return;
        }		//递归出口
        int j = partition(a, lo, hi); //已经归位
        sort(a, lo, j-1);
        sort(a, j+1, hi);
    }
    
    public static Comparable exchMid(Comparable[] a, int lo, int hi)
    {
        int mid = lo + (hi- lo)/2;
        if(less(a[mid], a[lo]))
            exch(a, lo, mid);
        if(less(a[hi], a[lo]))
            exch(a, lo, hi);
        if(less(a[hi], a[mid]))
            exch(a, mid, hi);
        exch(a, mid, hi-1);
        return a[hi-1];
    }
    
    
    public static int partition(Comparable[] a, int lo, int hi)
    {
        Comparable v = exchMid(a, lo, hi);
        //此时最右边的数一定比基准大，a[hi-1]是基准，所以从hi-2开始遍历
        int i = lo, j = hi - 1;
        while(true)
        {
            while(less(a[++i], v));//因为最右边的数比基准大，不需要考虑越界
            while(less(v, a[--j]));//最左边的数比基准小，不需要考虑越界
            if(i >= j) break;
            exch(a, i, j);
        }
        exch(a, i, hi - 1);
        return i;
    }
}
```

## 注意事项

### 原地切分

如果使用一个辅助数组，我们可以很容易的实现切分（==类似于归并排序，头尾两个指针，从`a[1]`开始比切分元素小的放在头部，比切分元素大的放在尾部，最后肯定剩余一个切分元素的位置==），但将切分元素复制回去的开销也许会让我们得不偿失。

### 别越界

如果切分元素是数组中最小或者最大的那个元素，我们就要小心别让扫描指针跑出数组的边界。但==三取样切分==可以避免这种越界检测。

### 保持随机性

数组元素是的顺序是被打乱过的，这样可以最大程度上保证算法的性能

## 算法改进

### 切换到插入排序

和大多数递归排序算法一样，改进快速排序性能的一个简单办法基于以下两点：

- 对于小数组，快速排序比插入排序慢；
- 因为递归，快速排序的`sort()`方法会在小数组中调用自己；

### 三取样切分

原始快速排序是采用数组中的第一个元素作为切分元素，但这不能很好的保证该元素恰巧能讲数组切分成大小差不多的两个数组。所以我们考虑的第二哥办法是使用子数组的一部分元素的中位数来切分数组。==将取样大小设为3并用大小居中的元素切分的效果最好。**还可以讲取样元素放在数组末尾作为“哨兵”来去掉`partition()`的数组边界测试**==

